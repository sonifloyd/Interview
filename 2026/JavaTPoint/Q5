public class Main    
{    
    Main(int a, int b)    
    {    
        System.out.println("a = "+a+" b = "+b);    
    }    
    Main(int a, float b)    
    {    
        System.out.println("a = "+a+" b = "+b);    
    }    
    public static void main (String args[])    
    {    
        byte a = 10;     
        byte b = 15;    
        Main obj = new Main(a,b);    
    }    
}    
Output:

a = 10 b = 15
-------------------
Important Concept: Type Promotion in Java
Java automatically promotes:
byte â†’ short â†’ int â†’ long â†’ float â†’ double
So byte can automatically become int.
---
Constructors Available
Main(int a, int b)
Main(int a, float b)


So we have two constructors:

(int, int)

(int, float)

ðŸ”¹ In main method
byte a = 10;
byte b = 15;

Main obj = new Main(a, b);


Here:

a is byte

b is byte

But constructors expect:

(int, int)

(int, float)

ðŸ”¥ Important Concept: Type Promotion in Java

Java automatically promotes:

byte â†’ short â†’ int â†’ long â†’ float â†’ double


So byte can automatically become int.

ðŸ”¹ What Happens Internally?

Call:

new Main(a, b);


Means:

new Main(byte, byte)


Java checks best matching constructor.

Option 1:
(byte â†’ int)
(byte â†’ int)


Matches (int, int) âœ”

Option 2:
(byte â†’ int)
(byte â†’ float)


Also possible, but this needs one extra conversion (int â†’ float).

Java always chooses the most specific / least conversion option.

So it selects:

Main(int a, int b)

âœ… Output:
a = 10 b = 15


From first constructor.

ðŸ”¥ Important Interview Rule

When multiple overloaded methods/constructors exist:

ðŸ‘‰ Java chooses the method with minimum type conversion.
