What is Method Overriding?

ğŸ‘‰ When a child class provides its own implementation of a method that is already defined in the parent class.

Simple words:

Same method name + same parameters + inheritance = Method Overriding

ğŸ”· Example
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    void sound() {   // overriding
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal obj = new Dog();
        obj.sound();
    }
}

ğŸ”¥ Output
Dog barks

ğŸ”¥ Why Dog method runs?

Because of Runtime Polymorphism.

Java decides at runtime which method to call.

ğŸ”· Rules of Method Overriding

1ï¸âƒ£ Must have inheritance (extends)
2ï¸âƒ£ Method name must be same
3ï¸âƒ£ Parameters must be same
4ï¸âƒ£ Return type must be same (or covariant)
5ï¸âƒ£ Access modifier cannot be more restrictive

ğŸ”¥ Example of Wrong Overriding
class Animal {
    void sound() {}
}

class Dog extends Animal {
    private void sound() {}   // âŒ ERROR
}


You cannot reduce visibility.

ğŸ”¥ Static Methods Cannot Be Overridden
class A {
    static void show() {}
}

class B extends A {
    static void show() {}
}


This is not overriding.
This is called method hiding.

ğŸ”¥ Real-Life Example

Parent: Bank account
Child: Savings account

Both have:

calculateInterest()


But savings account calculates differently.

ğŸ¯ Interview One-Line Answer

â€œMethod overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass.â€

ğŸ”¥ Important Difference
Overloading	Overriding
Same method name	Same method name
Different parameters	Same parameters
Compile-time	Runtime
No inheritance required	Inheritance required

If you want, I can explain:

super keyword in overriding

final method and overriding

real interview tricky questions ğŸ˜„

class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    void sound() {   // overriding
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal obj = new Dog(); agar yha pe animal obj = new animal karte ho kyaoutpit hita 
        obj.sound();
    }
}

Very good question ğŸ‘ğŸ”¥
You are thinking correctly about polymorphism.

You asked:

ğŸ‘‰ If we write:

Animal obj = new Animal();


Instead of:

Animal obj = new Dog();


Then what will be output?

ğŸ”· Case 1 (Original Code)
Animal obj = new Dog();
obj.sound();


Output:

Dog barks


Why?
Because object created is Dog.
At runtime Java checks object type â†’ Dog â†’ so Dogâ€™s method runs.

ğŸ”· Case 2 (Your Question)
Animal obj = new Animal();
obj.sound();


Now object created is Animal.

So output will be:

Animal makes sound

ğŸ”¥ Important Concept

In method overriding:

ğŸ‘‰ Method call depends on object type, not reference type.

ğŸ”· Understand This Clearly
Reference Type	Object Type	Output
Animal	Animal	Animal makes sound
Animal	Dog	Dog barks
Dog	Dog	Dog barks
ğŸ”¥ Key Rule (Very Important for Interview)

â€œMethod overriding follows runtime polymorphism, and the method is decided based on the object created, not reference type.â€

ğŸ”· Simple Real-Life Example

Think:

Animal obj = new Dog();


Reference = Animal
Object = Dog

But actual behavior depends on real object (Dog).
